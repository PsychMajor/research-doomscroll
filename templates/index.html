<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Doomscroll</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <!-- Initial Page Loading Spinner -->
    <div id="pageLoader" class="page-loader">
        <div class="loader-content">
            <div class="spinner"></div>
            <p class="loader-text">Loading Research Doomscroll...</p>
        </div>
    </div>

    <!-- Feed Generation Loading Overlay -->
    <div id="feedLoader" class="feed-loader hidden">
        <div class="loader-content">
            <div class="spinner"></div>
            <p class="loader-text">Generating your feed...</p>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <div class="header-top">
                <div class="header-title">
                    <h1>Research Doomscroll</h1>
                    <p class="subtitle">Infinite scroll through research papers</p>
                </div>
                <div class="header-actions">
                    {% if user and user.id != 'anonymous' %}
                        <div class="user-info">
                            <img src="{{ user.picture }}" alt="{{ user.name }}" class="user-avatar">
                            <span class="user-name">Welcome {{ user.name.split()[0] if user.name else user.email.split('@')[0] }}</span>
                            <a href="/logout" class="btn-logout">Logout</a>
                        </div>
                    {% else %}
                        <a href="/login" class="btn-login">Sign in with Google</a>
                    {% endif %}
                </div>
            </div>
        </header>
        
        <!-- Navigation Menu - Separate sticky element -->
        <nav class="nav-menu">
            <a href="/" class="nav-item active">Search</a>
            <div class="nav-item-dropdown">
                <a href="/likes" class="nav-item">Folders</a>
                <div class="dropdown-menu">
                    <a href="/likes" class="dropdown-item">Likes</a>
                </div>
            </div>
            <a href="#Following" class="nav-item">Following</a>
            <a href="#Recommended" class="nav-item">Recommended</a>
            <a href="#Contact" class="nav-item">Contact</a>
        </nav>
            
            {% if show_form %}
            <div class="search-form-wrapper" id="searchFormWrapper">
                <form class="search-form" method="POST" action="/profile/save" onsubmit="showFeedLoader()">

                <div class="form-group">
                    <label for="topics">
                        Topics & Keywords (Multiple Supported)
                    </label>
                    <input 
                        type="text" 
                        id="topics" 
                        name="topics" 
                        placeholder="e.g., GPCR signaling, beta-adrenergic receptors, drug discovery"
                        value="{{ topics }}"
                        class="form-input"
                    >
                    <span class="help-text">Separate multiple topics with commas - searches titles and abstracts</span>
                </div>
                
                <div class="form-group">
                    <label for="authors">
                        Authors (Multiple Supported)
                    </label>
                    <input 
                        type="text" 
                        id="authors" 
                        name="authors" 
                        placeholder="e.g., Brian Kobilka, Robert Lefkowitz, Roger Sunahara"
                        value="{{ authors }}"
                        class="form-input"
                    >
                    <span class="help-text">Separate multiple authors with commas - finds papers from ANY of these authors</span>
                </div>
                
                <div class="form-group">
                    <label for="sort_by">
                        Sort By
                    </label>
                    <select id="sort_by" name="sort_by" class="form-input">
                        <option value="recency" {% if sort_by == 'recency' or not sort_by %}selected{% endif %}>Recency (Newest First)</option>
                        <option value="relevance" {% if sort_by == 'relevance' %}selected{% endif %}>Relevance (Most Cited)</option>
                    </select>
                    <span class="help-text">Choose how to order the results</span>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="search-btn">
                        <span>Save Profile & Generate Feed</span>
                    </button>
                    {% if profile.topics %}
                    <form method="POST" action="/profile/clear" style="display: inline;">
                        <button type="submit" class="clear-btn">Clear Profile</button>
                    </form>
                    {% endif %}
                </div>
            </form>
            </div>
            {% endif %}
        </header>

    <script>
        // ============= SPA FRAMEWORK (Twitter-style) =============
        
        /**
         * Single Page Application Framework
         * Handles routing, state management, and view transitions without full page reloads
         */
        class SPAFramework {
            constructor() {
                this.currentView = null;
                this.viewCache = new Map(); // Cache view states
                this.isNavigating = false;
                
                // Initialize on page load
                this.init();
            }
            
            init() {
                console.log('üöÄ SPA Framework initializing...');
                
                // Intercept all navigation
                this.interceptLinks();
                
                // Handle browser back/forward
                window.addEventListener('popstate', (e) => this.handlePopState(e));
                
                // Save state before leaving
                window.addEventListener('beforeunload', () => this.saveCurrentView());
                
                console.log('‚úÖ SPA Framework ready');
            }
            
            interceptLinks() {
                // Intercept all link clicks
                document.addEventListener('click', (e) => {
                    const link = e.target.closest('a[href]');
                    if (!link) return;
                    
                    const href = link.getAttribute('href');
                    
                    // Skip external links, javascript:, mailto:, etc.
                    if (!href || 
                        href.startsWith('http://') || 
                        href.startsWith('https://') ||
                        href.startsWith('javascript:') ||
                        href.startsWith('mailto:') ||
                        href.startsWith('#')) {
                        return;
                    }
                    
                    // This is an internal navigation - handle with SPA
                    e.preventDefault();
                    this.navigateTo(href);
                }, true); // Use capture phase
            }
            
            async navigateTo(url, options = {}) {
                if (this.isNavigating) {
                    console.log('‚ö†Ô∏è  Navigation in progress, skipping...');
                    return;
                }
                
                console.log('üîÑ SPA navigating to:', url);
                this.isNavigating = true;
                
                try {
                    // Save current view state before leaving
                    this.saveCurrentView();
                    
                    // Check if we have a cached view
                    const cached = this.viewCache.get(url);
                    
                    if (cached && !options.forceReload) {
                        console.log('üìÇ Restoring from view cache:', url);
                        await this.restoreView(url, cached);
                    } else {
                        console.log('üåê Fetching fresh view:', url);
                        await this.fetchAndRenderView(url);
                    }
                    
                    // Update browser history
                    if (!options.replaceState) {
                        window.history.pushState({ url, timestamp: Date.now() }, '', url);
                    }
                    
                    this.currentView = url;
                    
                } catch (error) {
                    console.error('‚ùå Navigation error:', error);
                    // Fallback to full page load
                    window.location.href = url;
                } finally {
                    this.isNavigating = false;
                }
            }
            
            saveCurrentView() {
                const url = window.location.pathname + window.location.search;
                console.log('üíæ Saving current view:', url);
                
                // Save scroll position
                const scrollY = window.scrollY;
                
                // Save main content
                const container = document.querySelector('.container');
                const html = container ? container.innerHTML : '';
                
                // Save any page-specific state (using existing cache functions)
                if (typeof savePageState === 'function') {
                    savePageState();
                }
                
                this.viewCache.set(url, {
                    html,
                    scrollY,
                    timestamp: Date.now()
                });
                
                console.log('‚úÖ View saved to cache');
            }
            
            async restoreView(url, cached) {
                console.log('üîÑ Restoring cached view...');
                
                const container = document.querySelector('.container');
                if (container) {
                    // Restore HTML
                    container.innerHTML = cached.html;
                    
                    // Restore scroll position
                    requestAnimationFrame(() => {
                        window.scrollTo(0, cached.scrollY);
                        console.log('üìç Scroll restored to:', cached.scrollY);
                    });
                    
                    // Reinitialize page-specific features
                    this.reinitializeView();
                }
            }
            
            async fetchAndRenderView(url) {
                console.log('‚è≥ Fetching:', url);
                
                // Show loading indicator
                this.showLoadingIndicator();
                
                try {
                    const response = await fetch(url, {
                        headers: {
                            'X-SPA-Request': 'true' // Signal to server this is an SPA request
                        }
                    });
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const html = await response.text();
                    
                    // Parse the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Extract the container content
                    const newContainer = doc.querySelector('.container');
                    const currentContainer = document.querySelector('.container');
                    
                    if (newContainer && currentContainer) {
                        // Replace container content
                        currentContainer.innerHTML = newContainer.innerHTML;
                        
                        // Update page title if needed
                        const newTitle = doc.querySelector('title');
                        if (newTitle) {
                            document.title = newTitle.textContent;
                        }
                        
                        // Scroll to top
                        window.scrollTo(0, 0);
                        
                        // Reinitialize
                        this.reinitializeView();
                        
                        console.log('‚úÖ View rendered');
                    }
                    
                } finally {
                    this.hideLoadingIndicator();
                }
            }
            
            reinitializeView() {
                console.log('üîß Reinitializing view components...');
                
                // Update feedback state from current sets
                if (typeof likedPapers !== 'undefined' && typeof dislikedPapers !== 'undefined') {
                    console.log(`üìä Current feedback state: ${likedPapers.size} liked, ${dislikedPapers.size} disliked`);
                }
                
                // Reinitialize view (this will set up everything)
                if (typeof initializeView === 'function') {
                    setTimeout(() => {
                        initializeView();
                    }, 100); // Small delay to ensure DOM is ready
                } else {
                    console.warn('‚ö†Ô∏è  initializeView function not found');
                }
                
                console.log('‚úÖ View reinitialization queued');
            }
            
            handlePopState(e) {
                console.log('üîô Browser back/forward:', e.state);
                
                const url = window.location.pathname + window.location.search;
                
                // Navigate without pushing new history
                this.navigateTo(url, { replaceState: true });
            }
            
            showLoadingIndicator() {
                const loader = document.getElementById('pageLoader');
                if (loader) {
                    loader.classList.remove('hidden');
                    loader.style.display = 'flex';
                }
            }
            
            hideLoadingIndicator() {
                const loader = document.getElementById('pageLoader');
                if (loader) {
                    setTimeout(() => {
                        loader.classList.add('hidden');
                        setTimeout(() => {
                            loader.style.display = 'none';
                        }, 300);
                    }, 200);
                }
            }
            
            clearCache() {
                console.log('üóëÔ∏è  Clearing view cache');
                this.viewCache.clear();
            }
        }
        
        // Initialize SPA framework
        const spa = new SPAFramework();
        
        // ============= APPLICATION STATE =============
        
        // Store search parameters from the server
        const CURRENT_TOPICS = "{{ topics if topics else '' }}";
        const CURRENT_AUTHORS = "{{ authors if authors else '' }}";
        const USE_RECOMMENDATIONS = {{ 'true' if using_recommendations is defined and using_recommendations else 'false' }};
        
        console.log('Search params loaded:', { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS, useRec: USE_RECOMMENDATIONS });
        
        // Track liked and disliked papers
        let likedPapers = new Set({{ feedback.liked | tojson }});
        let dislikedPapers = new Set({{ feedback.disliked | tojson }});

        // Track which cards have been logged as visible
            const loggedCards = new Set();
            
            // Global observer for visibility tracking
            let observer = null;

        // ============= PAGINATION MANAGEMENT =============
        // Store all fetched papers and control progressive rendering
        let allPapers = [];
        let renderedCount = 0;
        const PAPERS_PER_PAGE = 20;
        
        // Track if page was restored from cache (global scope)
        let restoredFromCache = false;
        
        // Debug function to check pagination state
        window.checkPaginationState = function() {
            console.log('=== PAGINATION STATE DEBUG ===');
            console.log('allPapers.length:', allPapers.length);
            console.log('renderedCount:', renderedCount);
            console.log('PAPERS_PER_PAGE:', PAPERS_PER_PAGE);
            console.log('Cards in DOM:', document.querySelectorAll('.paper-card').length);
            console.log('allPapers sample:', allPapers.slice(0, 3).map(p => p.title));
            console.log('=============================');
        };

        // ============= CACHE MANAGEMENT (Session-based like Twitter) =============
        const CACHE_KEY = 'research_doomscroll_cache';
        const CACHE_VERSION = '1.0';
        const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

        function savePageState() {
            try {
                console.log('üíæ SAVE CALLED - Starting save process...');
                const feed = document.querySelector('.feed');
                if (!feed) {
                    console.log('‚ö†Ô∏è  Cannot save: No feed element found');
                    return;
                }

                // Collect all paper cards data (both rendered and unrendered)
                const visiblePapers = [];
                document.querySelectorAll('.paper-card').forEach(card => {
                    const paperJson = card.getAttribute('data-paper-json');
                    if (paperJson) {
                        visiblePapers.push(JSON.parse(paperJson));
                    }
                });

                // Track which abstracts are expanded
                const expandedAbstracts = [];
                document.querySelectorAll('.abstract-content').forEach(abstract => {
                    if (abstract.style.display !== 'none') {
                        const paperId = abstract.id.replace('abstract-', '');
                        expandedAbstracts.push(paperId);
                    }
                });

                const state = {
                    version: CACHE_VERSION,
                    timestamp: Date.now(),
                    scrollPosition: window.scrollY,
                    searchParams: {
                        topics: CURRENT_TOPICS,
                        authors: CURRENT_AUTHORS,
                        useRecommendations: USE_RECOMMENDATIONS
                    },
                    papers: visiblePapers,
                    allPapers: allPapers, // Store all fetched papers
                    renderedCount: renderedCount, // Store how many are rendered
                    expandedAbstracts: expandedAbstracts,
                    likedPapers: Array.from(likedPapers),
                    dislikedPapers: Array.from(dislikedPapers)
                };

                // Use sessionStorage for Twitter-like persistence
                sessionStorage.setItem(CACHE_KEY, JSON.stringify(state));
                
                // Verify it was saved
                const verification = sessionStorage.getItem(CACHE_KEY);
                console.log('üíæ STATE SAVED TO sessionStorage:', verification ? '‚úÖ SUCCESS' : '‚ùå FAILED');
                
                // Also save to history state for back/forward navigation
                window.history.replaceState(state, '', window.location.href);
                console.log('üíæ STATE SAVED TO history.state:', window.history.state ? '‚úÖ SUCCESS' : '‚ùå FAILED');
                
                console.log('üíæ FULL SAVE DETAILS:', {
                    visiblePapers: visiblePapers.length,
                    totalPapers: allPapers.length,
                    renderedCount: renderedCount,
                    expandedAbstracts: expandedAbstracts.length,
                    scrollPosition: window.scrollY,
                    searchParams: state.searchParams,
                    timestamp: new Date(state.timestamp).toLocaleTimeString(),
                    cacheKey: CACHE_KEY,
                    storageSize: JSON.stringify(state).length + ' bytes'
                });
            } catch (error) {
                console.error('‚ùå Error saving page state:', error);
            }
        }

        function loadPageState() {
            try {
                console.log('üìÇ LOAD CALLED - Checking for cached state...');
                console.log('üìÇ Checking history.state:', window.history.state);
                console.log('üìÇ Checking sessionStorage[' + CACHE_KEY + ']:', sessionStorage.getItem(CACHE_KEY) ? 'EXISTS' : 'NULL');
                
                // First check if we're navigating back via history
                if (window.history.state && window.history.state.version === CACHE_VERSION) {
                    console.log('üìÇ LOADING FROM HISTORY STATE (back/forward navigation)');
                    return window.history.state;
                }
                
                // Otherwise check sessionStorage
                const cached = sessionStorage.getItem(CACHE_KEY);
                if (!cached) {
                    console.log('üìÇ No cache found in sessionStorage');
                    return null;
                }

                const state = JSON.parse(cached);
                
                console.log('üìÇ CACHE FOUND (sessionStorage):', {
                    version: state.version,
                    papers: state.papers.length,
                    allPapers: state.allPapers ? state.allPapers.length : 'N/A',
                    renderedCount: state.renderedCount,
                    timestamp: new Date(state.timestamp).toLocaleTimeString(),
                    age: Math.round((Date.now() - state.timestamp) / 1000 / 60) + ' minutes old',
                    searchParams: state.searchParams
                });
                
                // Check cache version and expiry
                if (state.version !== CACHE_VERSION) {
                    console.log('‚ö†Ô∏è  Cache version mismatch (expected:', CACHE_VERSION, 'got:', state.version, '), clearing cache');
                    sessionStorage.removeItem(CACHE_KEY);
                    return null;
                }

                if (Date.now() - state.timestamp > CACHE_EXPIRY) {
                    console.log('‚è∞ Cache expired (age:', Math.round((Date.now() - state.timestamp) / 1000 / 60 / 60), 'hours), clearing cache');
                    sessionStorage.removeItem(CACHE_KEY);
                    return null;
                }

                console.log('‚úÖ Cache is valid and will be considered for restore');
                return state;
            } catch (error) {
                console.error('‚ùå Error loading page state:', error);
                return null;
            }
        }

        function clearPageCache() {
            sessionStorage.removeItem(CACHE_KEY);
            console.log('üóëÔ∏è  CACHE CLEARED - New search initiated');
        }

        function restorePageState(state) {
            if (!state || !state.papers || state.papers.length === 0) {
                console.log('‚ö†Ô∏è  Cannot restore: No papers in cached state');
                return false;
            }

            // Check if we're on the same search
            const sameSearch = state.searchParams.topics === CURRENT_TOPICS &&
                             state.searchParams.authors === CURRENT_AUTHORS;
            
            console.log('üîç SEARCH COMPARISON:', {
                cached: state.searchParams,
                current: { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS },
                sameSearch: sameSearch
            });
            
            if (!sameSearch) {
                console.log('üîÑ Different search parameters detected, NOT restoring cache');
                clearPageCache();
                return false;
            }

            const feed = document.querySelector('.feed');
            if (!feed) {
                console.log('‚ö†Ô∏è  Cannot restore: No feed element found');
                return false;
            }

            console.log('üîÑ RESTORING CACHE:', state.papers.length, 'papers');
            
            // Hide page loader immediately when restoring from cache (no animation needed)
            const pageLoader = document.getElementById('pageLoader');
            if (pageLoader) {
                pageLoader.style.display = 'none';
            }
            
            // Hide search form immediately when restoring from cache (no animation)
            const searchFormWrapper = document.getElementById('searchFormWrapper');
            if (searchFormWrapper) {
                searchFormWrapper.style.transition = 'none'; // Disable transition
                searchFormWrapper.classList.add('hidden');
                // Re-enable transitions after a frame so future interactions still animate
                setTimeout(() => {
                    searchFormWrapper.style.transition = '';
                }, 0);
            }

            // CRITICAL: Clear existing server-rendered papers to avoid conflicts
            feed.innerHTML = '';
            console.log('üßπ Cleared existing feed content');

            // Build HTML for cached papers
            let html = '';
            state.papers.forEach((paper, index) => {
                const cardNumber = index + 1;
                const isExpanded = state.expandedAbstracts.includes(paper.paperId);
                
                // Format authors properly
                let authorsHtml = '';
                if (paper.authors && Array.isArray(paper.authors)) {
                    if (paper.authors.length <= 4) {
                        authorsHtml = paper.authors.map(a => a.name || a).join(', ');
                    } else {
                        const first = paper.authors[0].name || paper.authors[0];
                        const second = paper.authors[1].name || paper.authors[1];
                        const secondLast = paper.authors[paper.authors.length - 2].name || paper.authors[paper.authors.length - 2];
                        const last = paper.authors[paper.authors.length - 1].name || paper.authors[paper.authors.length - 1];
                        authorsHtml = `${first}, ${second}, ... ${secondLast}, ${last}`;
                    }
                } else if (typeof paper.authors === 'string') {
                    authorsHtml = paper.authors;
                }
                
                html += `
                <article class="paper-card" data-card-number="${cardNumber}" data-paper-id="${paper.paperId}" data-paper-json='${JSON.stringify(paper).replace(/'/g, "&apos;")}'>
                    <div class="card-header">
                        <div class="paper-meta">
                            <h2 class="paper-title">${paper.title}</h2>
                            <div class="paper-info">
                                ${authorsHtml ? `<span class="authors">${authorsHtml}</span>` : ''}
                                <span class="separator">‚Ä¢</span>
                                <span class="year">${paper.year || ''}</span>
                                ${paper.venue ? `<span class="separator">‚Ä¢</span><span class="venue">${paper.venue}</span>` : ''}
                                ${paper.citationCount > 0 ? `<span class="separator">‚Ä¢</span><span class="citations">${paper.citationCount} citations</span>` : ''}
                            </div>
                        </div>
                    </div>
                    
                    ${paper.tldr ? `
                    <div class="paper-tldr">
                        <strong>TL;DR:</strong> ${paper.tldr}
                    </div>
                    ` : ''}
                    
                    <div class="paper-abstract-container">
                        <button class="abstract-toggle" onclick="toggleAbstract('${paper.paperId}')">
                            <span class="toggle-icon">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>
                            <span class="toggle-text">Abstract</span>
                        </button>
                        <div class="paper-abstract" id="abstract-${paper.paperId}" style="display: ${isExpanded ? 'block' : 'none'};">
                            ${paper.abstract ? paper.abstract : '<em class="no-abstract">No abstract available</em>'}
                        </div>
                    </div>

                    <div class="card-footer">
                        ${paper.url ? `
                        <a href="${paper.url}" class="paper-link" target="_blank" rel="noopener noreferrer">
                            <span>${paper.source === 'bioRxiv' ? 'Read on bioRxiv' : 'Read on publisher\'s page'}</span>
                            <span class="link-icon">‚Üó</span>
                        </a>
                        ` : ''}
                        <div class="card-actions">
                            <button class="like-btn" onclick="likePaper('${paper.paperId}', event)" title="Like this paper">
                                <span class="like-text">Like</span>
                            </button>
                            <button class="dislike-btn" onclick="dislikePaper('${paper.paperId}', event)" title="Dislike this paper">
                                <span class="dislike-text">Pass</span>
                            </button>
                        </div>
                    </div>
                </article>
                `;
            });

            feed.innerHTML = html;

            // Restore feedback state UI
            console.log(`üéØ Restoring feedback state: ${state.likedPapers.length} liked, ${state.dislikedPapers.length} disliked`);
            
            state.likedPapers.forEach(paperId => {
                // Find card by data-paper-id attribute
                const card = document.querySelector(`[data-paper-id="${paperId}"]`);
                if (card) {
                    const btn = card.querySelector('.like-btn');
                    if (btn) {
                        btn.classList.add('active');
                        btn.querySelector('.like-text').textContent = 'Liked!';
                        console.log(`‚úÖ Restored liked state for paper ${paperId}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Could not find like button for paper ${paperId}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Could not find card for liked paper ${paperId}`);
                }
            });

            state.dislikedPapers.forEach(paperId => {
                // Find card by data-paper-id attribute
                const card = document.querySelector(`[data-paper-id="${paperId}"]`);
                if (card) {
                    const btn = card.querySelector('.dislike-btn');
                    if (btn) {
                        btn.classList.add('active');
                        card.style.opacity = '0.3';
                        card.style.transform = 'translateX(-20px)';
                        console.log(`‚úÖ Restored disliked state for paper ${paperId}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Could not find dislike button for paper ${paperId}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Could not find card for disliked paper ${paperId}`);
                }
            });

            // Re-setup observers for restored cards
            document.querySelectorAll('.paper-card').forEach(card => {
                if (observer) {
                    observer.observe(card);
                }
            });

            console.log('‚ú® RESTORE COMPLETE:', state.papers.length, 'papers restored');
            
            // Restore scroll position after DOM is fully rendered
            const targetScrollPos = state.scrollPosition;
            console.log(`üìç Target scroll position: ${targetScrollPos}px`);
            
            // Use requestAnimationFrame to ensure DOM has painted
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // Double RAF ensures layout is complete
                    console.log(`üìè Document height after restore: ${document.documentElement.scrollHeight}px`);
                    window.scrollTo(0, targetScrollPos);
                    console.log(`‚úÖ Scroll restored to ${targetScrollPos}px (current: ${window.scrollY}px)`);
                    
                    // Final check after images/content load
                    setTimeout(() => {
                        const currentScroll = window.scrollY;
                        if (Math.abs(currentScroll - targetScrollPos) > 50) {
                            console.log(`ÔøΩ Scroll position drifted, re-applying...`);
                            window.scrollTo(0, targetScrollPos);
                            console.log(`‚úÖ Final scroll: ${window.scrollY}px`);
                        }
                    }, 300);
                });
            });

            return true;
        }

        // Auto-save state before leaving page
        window.addEventListener('beforeunload', () => {
            savePageState();
        });
        
        // Handle back/forward navigation (Twitter-style)
        window.addEventListener('popstate', (event) => {
            console.log('üîô Browser back/forward navigation detected');
            if (event.state && event.state.version === CACHE_VERSION) {
                console.log('üìÇ Restoring from history state...');
                location.reload(); // Reload to restore from cache
            }
        });

        // Auto-save state periodically (every 30 seconds)
        setInterval(() => {
            savePageState();
        }, 30000);

        // Save state when scrolling stops
        let scrollSaveTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(() => {
                savePageState();
            }, 1000);
        }, { passive: true });

        // Save state when liking/disliking papers
        const originalLikePaper = likePaper;
        const originalDislikePaper = dislikePaper;

        // ============= VIEW INITIALIZATION FUNCTION (for SPA) =============
        function initializeView() {
            console.log('ÔøΩ Initializing view...');
            
            // Check if we're on the search page (has search form)
            const searchForm = document.querySelector('.search-form');
            if (!searchForm) {
                console.log('‚è≠Ô∏è  Not on search page, skipping initialization');
                return;
            }
            
            // Set up Intersection Observer
            setupObserver();
            
            // Initialize pagination from server-rendered papers (if any)
            const feed = document.querySelector('.feed');
            if (feed) {
                const paperCards = document.querySelectorAll('.paper-card');
                console.log(`üìä Found ${paperCards.length} paper cards in DOM`);
                
                // If we have server papers and haven't initialized yet
                if (typeof window._serverPapers !== 'undefined' && window._serverPapers && allPapers.length === 0) {
                    allPapers = window._serverPapers;
                    renderedCount = paperCards.length;
                    console.log(`üìä PAGINATION INITIALIZED: ${allPapers.length} papers fetched, ${renderedCount} rendered`);
                }
                
                // If we already have papers, just update rendered count
                if (allPapers.length > 0 && renderedCount === 0) {
                    renderedCount = paperCards.length;
                    console.log(`üìä Updated renderedCount: ${renderedCount} of ${allPapers.length}`);
                }
            }
            
            // Try to restore from cache first
            const cachedState = loadPageState();
            restoredFromCache = false;
            
            if (cachedState && cachedState.papers && cachedState.papers.length > 0) {
                const currentPaperCount = document.querySelectorAll('.paper-card').length;
                
                console.log('üîç RESTORE DECISION:', {
                    currentPaperCount: currentPaperCount,
                    cachedPaperCount: cachedState.papers.length,
                    decision: cachedState.papers.length > currentPaperCount ? 'RESTORE CACHE' : 'USE CURRENT'
                });
                
                if (cachedState.papers.length > currentPaperCount) {
                    restoredFromCache = restorePageState(cachedState);
                    if (restoredFromCache) {
                        allPapers = cachedState.allPapers || cachedState.papers;
                        renderedCount = cachedState.renderedCount || cachedState.papers.length;
                        console.log(`üìä PAGINATION RESTORED FROM CACHE: ${allPapers.length} total, ${renderedCount} rendered`);
                    }
                }
            }
            
            // Mark feedback states
            markFeedbackStates();
            
            // Hide page loader
            const pageLoader = document.getElementById('pageLoader');
            if (pageLoader && pageLoader.style.display !== 'none') {
                setTimeout(() => {
                    pageLoader.classList.add('hidden');
                    setTimeout(() => {
                        pageLoader.style.display = 'none';
                    }, 300);
                }, 200);
            }
            
            console.log('‚úÖ View initialized');
        }
        
        // ============= OBSERVER SETUP FUNCTION =============
        function setupObserver() {
            console.log('üî≠ Setting up Intersection Observer...');
            
            // Disconnect existing observer if any
            if (observer) {
                observer.disconnect();
                console.log('ÔøΩ Disconnected old observer');
            }
            
            const observerOptions = {
                root: null,
                rootMargin: '0px',
                threshold: 0.75
            };

            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.75) {
                        const card = entry.target;
                        const cardNumber = card.dataset.cardNumber;
                        const paperId = card.dataset.paperId;
                        
                        if (!loggedCards.has(paperId)) {
                            loggedCards.add(paperId);
                            logCardVisible(cardNumber, paperId);
                            
                            const allCards = document.querySelectorAll('.paper-card');
                            const currentIndex = Array.from(allCards).indexOf(card);
                            
                            console.log(`ÔøΩ Card visible: #${cardNumber} (index ${currentIndex} of ${allCards.length} total cards)`);
                            console.log(`üìä Pagination state: ${renderedCount} rendered of ${allPapers.length} total papers`);
                            
                            if (currentIndex === allCards.length - 2) {
                                console.log(`üîî SECOND-TO-LAST CARD DETECTED: Card #${cardNumber}`);
                                logSecondToLastCard(cardNumber, paperId, allCards.length);
                                
                                const remainingPapers = allPapers.length - renderedCount;
                                
                                if (remainingPapers > 0) {
                                    console.log(`üîÑ Auto-rendering next batch...`);
                                    renderNextBatch();
                                } else {
                                    console.log(`üåê Fetching more unique papers...`);
                                    fetchMoreUniquePapers();
                                }
                            }
                        }
                    }
                });
            }, observerOptions);
            
            // Observe all paper cards
            const cards = document.querySelectorAll('.paper-card');
            cards.forEach(card => observer.observe(card));
            console.log(`‚úÖ Observer watching ${cards.length} cards`);
        }
        
        // ============= FEEDBACK STATE MARKING =============
        function markFeedbackStates() {
            console.log(`üéØ Marking feedback states: ${likedPapers.size} liked, ${dislikedPapers.size} disliked`);
            
            likedPapers.forEach(paperId => {
                const card = document.querySelector(`[data-paper-id="${paperId}"]`);
                if (card) {
                    const btn = card.querySelector('.like-btn');
                    if (btn) {
                        btn.classList.add('active');
                        const textEl = btn.querySelector('.like-text');
                        if (textEl) textEl.textContent = 'Liked!';
                    }
                }
            });

            dislikedPapers.forEach(paperId => {
                const card = document.querySelector(`[data-paper-id="${paperId}"]`);
                if (card) {
                    const btn = card.querySelector('.dislike-btn');
                    if (btn) {
                        btn.classList.add('active');
                        card.style.opacity = '0.3';
                        card.style.transform = 'translateX(-20px)';
                    }
                }
            });
        }

            // Page load initialization
            window.addEventListener('DOMContentLoaded', function() {
                console.log('üöÄ PAGE LOAD - DOMContentLoaded');
                console.log('üìã Current search params:', { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS });
                
                // Store server papers globally for initializeView
                const serverPapers = {{ papers | tojson | safe }};
                window._serverPapers = serverPapers;
                console.log('üîß SERVER PAPERS:', serverPapers ? serverPapers.length : 0, 'papers received');
                
                // Initialize the view
                initializeView();

                // Auto-hide/show header on scroll
                let lastScrollTop = 0;
                let scrollTimeout;
                const header = document.querySelector('.header');
                const scrollThreshold = 150; // Minimum scroll distance to trigger hide
                const showThreshold = 80; // Minimum scroll-up distance to show header
                
                window.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    
                    scrollTimeout = setTimeout(function() {
                        let scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        let scrollDelta = scrollTop - lastScrollTop;
                        
                        if (scrollDelta > 5 && scrollTop > scrollThreshold) {
                            // Scrolling down & past threshold
                            header.classList.add('header-hidden');
                        } else if (scrollDelta < -showThreshold) {
                            // Scrolling up at least 80px
                            header.classList.remove('header-hidden');
                        } else if (scrollTop <= 0) {
                            // At top of page
                            header.classList.remove('header-hidden');
                        }
                        
                        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
                    }, 20); // Reduced debounce for more responsive feel
                }, { passive: true });
            });

            async function logCardVisible(cardNumber, paperId) {
                try {
                    const formData = new FormData();
                    formData.append('card_number', cardNumber);
                    formData.append('paper_id', paperId);
                    
                    await fetch('/card/visible', {
                        method: 'POST',
                        body: formData
                    });
                } catch (error) {
                    console.error('Error logging card visibility:', error);
                }
            }

            async function logSecondToLastCard(cardNumber, paperId, totalCards) {
                try {
                    const formData = new FormData();
                    formData.append('card_number', cardNumber);
                    formData.append('paper_id', paperId);
                    formData.append('total_cards', totalCards);
                    
                    await fetch('/card/second-to-last', {
                        method: 'POST',
                        body: formData
                    });
                } catch (error) {
                    console.error('Error logging second-to-last card:', error);
                }
            }

            function updateFeedbackStats() {
                const likedCountEl = document.getElementById('likedCount');
                const dislikedCountEl = document.getElementById('dislikedCount');
                
                if (likedCountEl) likedCountEl.textContent = likedPapers.size;
                if (dislikedCountEl) dislikedCountEl.textContent = dislikedPapers.size;
            }

            function showFeedLoader() {
                // Only clear cache if search params are actually changing
                const form = document.querySelector('.search-form');
                const newTopics = form.querySelector('#topics').value.trim();
                const newAuthors = form.querySelector('#authors').value.trim();
                
                const searchChanged = newTopics !== CURRENT_TOPICS || newAuthors !== CURRENT_AUTHORS;
                
                console.log('üîç SEARCH SUBMISSION:', {
                    currentTopics: CURRENT_TOPICS,
                    currentAuthors: CURRENT_AUTHORS,
                    newTopics: newTopics,
                    newAuthors: newAuthors,
                    searchChanged: searchChanged
                });
                
                if (searchChanged) {
                    clearPageCache();
                } else {
                    console.log('üìå Same search parameters, keeping cache');
                }
                
                const feedLoader = document.getElementById('feedLoader');
                if (feedLoader) {
                    feedLoader.classList.remove('hidden');
                }
                
                // Hide search form after submission
                const wrapper = document.getElementById('searchFormWrapper');
                if (wrapper) {
                    setTimeout(() => {
                        wrapper.classList.add('hidden');
                    }, 300);
                }
            }
            
            function showSearchForm() {
                const wrapper = document.getElementById('searchFormWrapper');
                
                // If wrapper doesn't exist, we're on a different page - navigate to home
                // This will restore cached state if available
                if (!wrapper) {
                    console.log('üîô Navigating to home page (will restore cache if available)');
                    window.location.href = '/';
                    return;
                }
                
                // Show the form if we're already on the home page
                if (wrapper) {
                    wrapper.classList.remove('hidden');
                    
                    // Get the nav menu height to offset the scroll
                    const navMenu = document.querySelector('.nav-menu');
                    const navHeight = navMenu ? navMenu.offsetHeight : 0;
                    
                    // Scroll to the form with offset for sticky nav
                    setTimeout(() => {
                        const wrapperTop = wrapper.getBoundingClientRect().top + window.pageYOffset;
                        const offsetPosition = wrapperTop - navHeight;
                        
                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });
                    }, 100); // Small delay to ensure the wrapper is visible
                }
                
                console.log('üìù Search form shown (no auto-search)');
            }
            
            // Hide form on page load if there are papers (but not if restored from cache)
            document.addEventListener('DOMContentLoaded', function() {
                const wrapper = document.getElementById('searchFormWrapper');
                // Check if there are papers in the feed
                const papers = {{ papers | tojson | safe }};
                
                // Only hide with animation if we have papers AND didn't restore from cache
                if (papers && papers.length > 0 && wrapper && !restoredFromCache) {
                    // Add a small delay to ensure smooth transition
                    setTimeout(() => {
                        wrapper.classList.add('hidden');
                    }, 100);
                }
            });

        function toggleFeed() {
            const feedContainer = document.getElementById('feedContainer');
            const icon = document.getElementById('feedToggleIcon');
            const toggleBtn = document.getElementById('feedToggleBtn');
            const loadMoreContainer = document.getElementById('loadMoreContainer');
            
            feedContainer.classList.toggle('collapsed');
            
            if (feedContainer.classList.contains('collapsed')) {
                icon.textContent = '‚ñ∂';
                toggleBtn.classList.add('collapsed');
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
            } else {
                icon.textContent = '‚ñº';
                toggleBtn.classList.remove('collapsed');
                if (loadMoreContainer) loadMoreContainer.style.display = 'flex';
            }
        }

        function toggleFilters() {
            const filtersContent = document.getElementById('filtersContent');
            const icon = document.getElementById('filterToggleIcon');
            const toggleBtn = document.getElementById('filterToggleBtn');
            
            filtersContent.classList.toggle('collapsed');
            
            if (filtersContent.classList.contains('collapsed')) {
                icon.textContent = '‚ñ∂';
                toggleBtn.classList.add('collapsed');
            } else {
                icon.textContent = '‚ñº';
                toggleBtn.classList.remove('collapsed');
            }
        }

        // ============= PAGINATION: Render Next Batch =============
        function renderNextBatch() {
            console.log(`üéØ renderNextBatch() called - renderedCount: ${renderedCount}, allPapers.length: ${allPapers.length}`);
            
            if (renderedCount >= allPapers.length) {
                console.log(`‚úÖ All papers loaded (${allPapers.length} of ${allPapers.length})`);
                return false;
            }

            const nextBatch = allPapers.slice(renderedCount, renderedCount + PAPERS_PER_PAGE);
            if (nextBatch.length === 0) {
                console.log(`‚úÖ No more papers to render`);
                return false;
            }

            console.log(`üìÑ Loading next ${nextBatch.length} papers (currently showing ${renderedCount} of ${allPapers.length})`);
            console.log(`üìÑ Next batch papers:`, nextBatch.map(p => p.title).slice(0, 3));

            const feed = document.querySelector('.feed');
            if (!feed) {
                console.error('‚ùå Cannot render: No feed element found');
                return false;
            }

            // Create and append cards for next batch
            nextBatch.forEach((paper, index) => {
                const cardNumber = renderedCount + index + 1;
                const card = createPaperCard(paper, cardNumber);
                feed.appendChild(card);
            });

            renderedCount += nextBatch.length;
            
            // Set up observers for new cards
            if (observer) {
                document.querySelectorAll('.paper-card').forEach(card => {
                    observer.observe(card);
                });
            }

            // Save state with updated rendered count
            savePageState();

            console.log(`‚úÖ Rendered ${nextBatch.length} papers. Total visible: ${renderedCount} of ${allPapers.length}`);
            return true;
        }

        // ============= FETCH MORE UNIQUE PAPERS =============
        async function fetchMoreUniquePapers() {
            console.log('üîÑ ========================================');
            console.log('üîÑ fetchMoreUniquePapers() CALLED');
            console.log('üîÑ ========================================');
            
            // Get existing paper IDs to avoid duplicates
            const existingPaperIds = new Set(allPapers.map(p => p.paperId));
            console.log(`üìã Existing paper IDs: ${existingPaperIds.size} papers`);
            console.log(`üìã First 5 IDs:`, Array.from(existingPaperIds).slice(0, 5));
            
            // Calculate which page to fetch (we fetched 200 papers initially, so page 2)
            const currentPage = Math.floor(allPapers.length / 200) + 1;
            console.log(`üìÑ Current page to fetch: ${currentPage} (based on ${allPapers.length} papers)`);
            
            try {
                // Build fetch URL with same search params
                const params = new URLSearchParams();
                if (CURRENT_TOPICS) {
                    params.append('topics', CURRENT_TOPICS);
                    console.log(`üîç Topics: ${CURRENT_TOPICS}`);
                }
                if (CURRENT_AUTHORS) {
                    params.append('authors', CURRENT_AUTHORS);
                    console.log(`üë§ Authors: ${CURRENT_AUTHORS}`);
                }
                params.append('page', currentPage);
                params.append('per_page', 200);
                params.append('sort_by', 'recency');
                
                const url = `/api/fetch-papers?${params.toString()}`;
                console.log(`üåê Fetching from URL: ${url}`);
                
                console.log(`‚è≥ Sending fetch request...`);
                const response = await fetch(url);
                console.log(`‚úÖ Response received, status: ${response.status}`);
                
                const data = await response.json();
                console.log(`üì• Response data:`, {
                    status: data.status,
                    paperCount: data.papers ? data.papers.length : 0,
                    page: data.page,
                    per_page: data.per_page,
                    hasError: data.message ? true : false,
                    errorMessage: data.message || 'none'
                });
                
                if (data.papers && data.papers.length > 0) {
                    console.log(`üìù First paper from API:`, {
                        id: data.papers[0].paperId,
                        title: data.papers[0].title.substring(0, 50) + '...'
                    });
                    
                    // Filter out duplicates
                    const newPapers = data.papers.filter(paper => {
                        const isDuplicate = existingPaperIds.has(paper.paperId);
                        if (isDuplicate) {
                            console.log(`   ‚ö†Ô∏è Duplicate found: ${paper.paperId}`);
                        }
                        return !isDuplicate;
                    });
                    
                    console.log(`‚ú® Deduplication results:`);
                    console.log(`   Received: ${data.papers.length} papers`);
                    console.log(`   Duplicates: ${data.papers.length - newPapers.length} papers`);
                    console.log(`   New unique: ${newPapers.length} papers`);
                    
                    if (newPapers.length > 0) {
                        console.log(`üìö Adding ${newPapers.length} new papers to allPapers array...`);
                        
                        // Add new papers to allPapers array
                        const beforeCount = allPapers.length;
                        allPapers.push(...newPapers);
                        const afterCount = allPapers.length;
                        
                        console.log(`üìö Total papers: ${beforeCount} ‚Üí ${afterCount} (+${afterCount - beforeCount})`);
                        
                        // Automatically render the first batch of new papers
                        console.log(`üé® Calling renderNextBatch() to display new papers...`);
                        const rendered = renderNextBatch();
                        console.log(`üé® renderNextBatch() returned: ${rendered}`);
                        
                        // Save updated cache
                        console.log(`üíæ Saving updated cache...`);
                        savePageState();
                        
                        console.log(`‚úÖ SUCCESS: Added ${newPapers.length} new unique papers`);
                        console.log(`‚úÖ Current state: ${renderedCount} rendered of ${allPapers.length} total`);
                    } else {
                        console.log(`‚ö†Ô∏è No new unique papers found (all ${data.papers.length} were duplicates)`);
                    }
                } else {
                    console.log(`‚ö†Ô∏è No papers in API response`);
                    if (data.message) {
                        console.log(`   Error message: ${data.message}`);
                    }
                }
            } catch (error) {
                console.error('‚ùå ERROR in fetchMoreUniquePapers:', error);
                console.error('‚ùå Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
            }
            
            console.log('üîÑ ========================================');
            console.log('üîÑ fetchMoreUniquePapers() COMPLETE');
            console.log('üîÑ ========================================');
        }

        // Helper function to create a paper card element from paper data
        function createPaperCard(paper, cardNumber) {
            const article = document.createElement('article');
            article.className = 'paper-card';
            article.setAttribute('data-card-number', cardNumber);
            article.setAttribute('data-paper-id', paper.paperId);
            article.setAttribute('data-paper-json', JSON.stringify(paper));

            // Format authors
            let authorsHtml = '';
            if (paper.authors && Array.isArray(paper.authors)) {
                if (paper.authors.length <= 4) {
                    authorsHtml = paper.authors.map(a => a.name || a).join(', ');
                } else {
                    const first = paper.authors[0].name || paper.authors[0];
                    const second = paper.authors[1].name || paper.authors[1];
                    const secondLast = paper.authors[paper.authors.length - 2].name || paper.authors[paper.authors.length - 2];
                    const last = paper.authors[paper.authors.length - 1].name || paper.authors[paper.authors.length - 1];
                    authorsHtml = `${first}, ${second}, ... ${secondLast}, ${last}`;
                }
            } else if (typeof paper.authors === 'string') {
                authorsHtml = paper.authors;
            }

            article.innerHTML = `
                <div class="card-header">
                    <div class="paper-meta">
                        <h2 class="paper-title">${paper.title || 'Untitled'}</h2>
                        <div class="paper-info">
                            ${authorsHtml ? `<span class="authors">${authorsHtml}</span>` : ''}
                            <span class="separator">‚Ä¢</span>
                            <span class="year">${paper.year || ''}</span>
                            ${paper.venue ? `<span class="separator">‚Ä¢</span><span class="venue">${paper.venue}</span>` : ''}
                            ${paper.citationCount > 0 ? `<span class="separator">‚Ä¢</span><span class="citations">${paper.citationCount} citations</span>` : ''}
                        </div>
                    </div>
                </div>

                ${paper.tldr ? `<div class="paper-tldr"><strong>TL;DR:</strong> ${paper.tldr}</div>` : ''}

                <div class="paper-abstract-container">
                    <button class="abstract-toggle" onclick="toggleAbstract('${paper.paperId}')">
                        <span class="toggle-icon">‚ñ∂</span>
                        <span class="toggle-text">Abstract</span>
                    </button>
                    <div class="paper-abstract" id="abstract-${paper.paperId}" style="display: none;">
                        ${paper.abstract ? paper.abstract : '<em class="no-abstract">No abstract available</em>'}
                    </div>
                </div>

                <div class="card-footer">
                    ${paper.url ? `
                        <a href="${paper.url}" class="paper-link" target="_blank" rel="noopener noreferrer">
                            <span>Read on ${paper.source === 'bioRxiv' ? 'bioRxiv' : paper.source === 'OpenAlex' ? "publisher's page" : 'Semantic Scholar'}</span>
                            <span class="link-icon">‚Üó</span>
                        </a>
                    ` : ''}
                    <div class="card-actions">
                        <button class="like-btn ${likedPapers.has(paper.paperId) ? 'active' : ''}" onclick="likePaper('${paper.paperId}', event)" title="Like this paper">
                            <span class="like-text">${likedPapers.has(paper.paperId) ? 'Liked' : 'Like'}</span>
                        </button>
                        <button class="dislike-btn ${dislikedPapers.has(paper.paperId) ? 'active' : ''}" onclick="dislikePaper('${paper.paperId}', event)" title="Dislike this paper">
                            <span class="dislike-text">Pass</span>
                        </button>
                    </div>
                </div>
            `;

            return article;
        }


        async function likePaper(paperId, event) {
                try {
                    const btn = event.target.closest('.like-btn');
                    const card = btn.closest('.paper-card');
                    
                    // Check if already liked - if so, unlike it
                    if (likedPapers.has(paperId)) {
                        // Unlike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        const response = await fetch('/paper/unlike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            likedPapers.delete(paperId);
                            btn.classList.remove('active');
                            btn.querySelector('.like-text').textContent = 'Like';
                            btn.disabled = false;
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    } else {
                        // Like the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        // Get paper data from card
                        const paperJson = card.getAttribute('data-paper-json');
                        if (paperJson) {
                            formData.append('paper_data', paperJson);
                        }
                        
                        const response = await fetch('/paper/like', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            // Remove from disliked if present
                            if (dislikedPapers.has(paperId)) {
                                dislikedPapers.delete(paperId);
                            }
                            
                            likedPapers.add(paperId);
                            btn.classList.add('active');
                            btn.querySelector('.like-text').textContent = 'Liked!';
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    }
                } catch (error) {
                    console.error('Error with like/unlike:', error);
                }
            }

            async function dislikePaper(paperId, event) {
                try {
                    const btn = event.target.closest('.dislike-btn');
                    const card = btn.closest('.paper-card');
                    
                    // Check if already disliked - if so, undislike it
                    if (dislikedPapers.has(paperId)) {
                        // Undislike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        const response = await fetch('/paper/undislike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            dislikedPapers.delete(paperId);
                            btn.classList.remove('active');
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    } else {
                        // Dislike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        // Get paper data from card
                        const paperJson = card.getAttribute('data-paper-json');
                        if (paperJson) {
                            formData.append('paper_data', paperJson);
                        }
                        
                        const response = await fetch('/paper/dislike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            // Remove from liked if present
                            if (likedPapers.has(paperId)) {
                                likedPapers.delete(paperId);
                                const likeBtn = card.querySelector('.like-btn');
                                if (likeBtn) {
                                    likeBtn.classList.remove('active');
                                    likeBtn.querySelector('.like-text').textContent = 'Like';
                                }
                            }
                            
                            dislikedPapers.add(paperId);
                            btn.classList.add('active');
                            card.style.opacity = '0.3';
                            card.style.transform = 'translateX(-20px)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    }
                } catch (error) {
                    console.error('Error with dislike/undislike:', error);
                }
            }

            function toggleAbstract(paperId) {
                const abstractDiv = document.getElementById(`abstract-${paperId}`);
                const toggleButton = abstractDiv.parentElement.querySelector('.abstract-toggle');
                const icon = toggleButton.querySelector('.toggle-icon');
                
                if (abstractDiv.style.display === 'none') {
                    abstractDiv.style.display = 'block';
                    icon.textContent = '‚ñº';
                    toggleButton.classList.add('expanded');
                } else {
                    abstractDiv.style.display = 'none';
                    icon.textContent = '‚ñ∂';
                    toggleButton.classList.remove('expanded');
                }
                
                // Save state after toggling abstract
                savePageState();
            }

            function showClearModal() {
                document.getElementById('clearModal').style.display = 'flex';
            }

            function closeClearModal() {
                document.getElementById('clearModal').style.display = 'none';
            }

            // Close modal when clicking outside
            window.onclick = function(event) {
                const modal = document.getElementById('clearModal');
                if (event.target === modal) {
                    closeClearModal();
                }
            }

            function openSidebar(url, title) {
                const sidebar = document.getElementById('paperSidebar');
                const iframe = document.getElementById('paperFrame');
                const titleEl = document.getElementById('sidebarTitle');
                const overlay = document.getElementById('sidebarOverlay');
                
                // Use our proxy to bypass X-Frame-Options
                const proxyUrl = `/proxy?url=${encodeURIComponent(url)}`;
                
                titleEl.textContent = title;
                iframe.src = proxyUrl;
                sidebar.classList.add('active');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeSidebar() {
                const sidebar = document.getElementById('paperSidebar');
                const iframe = document.getElementById('paperFrame');
                const overlay = document.getElementById('sidebarOverlay');
                
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
                iframe.src = '';
                document.body.style.overflow = 'auto';
            }

            async function loadMorePapers() {
                const btn = document.getElementById('loadMoreBtn');
                const btnText = btn.querySelector('.load-more-text');
                const btnIcon = btn.querySelector('.load-more-icon');
                
                // Show loading state
                btn.disabled = true;
                btnText.textContent = 'Loading...';
                btnIcon.textContent = '‚ü≥';
                btnIcon.style.animation = 'spin 1s linear infinite';
                
                try {
                    // Use the stored search parameters instead of URL params
                    const topics = CURRENT_TOPICS;
                    const authors = CURRENT_AUTHORS;
                    const useRecommendations = USE_RECOMMENDATIONS;
                    
                    // Build the API URL
                    let apiUrl = '/api/load-more?';
                    if (topics) apiUrl += `topics=${encodeURIComponent(topics)}&`;
                    if (authors) apiUrl += `authors=${encodeURIComponent(authors)}&`;
                    if (useRecommendations) apiUrl += `use_recommendations=${useRecommendations}&`;
                    
                    console.log('Load More API URL:', apiUrl);
                    
                    // Fetch new papers
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    
                    console.log('Load More Response:', data);
                    console.log('Papers count:', data.papers ? data.papers.length : 0);
                    console.log('From cache:', data.from_cache);
                    
                    if (data.papers && data.papers.length > 0) {
                        // Get the feed container
                        const feed = document.querySelector('.feed');
                        
                        console.log('Feed element found:', !!feed);
                        
                        // Restart numbering from 1 for each load more batch
                        // Append each new paper
                        data.papers.forEach((paper, index) => {
                            const cardNumber = index + 1;  // Restart from 1 each time
                            const cardHtml = createPaperCard(paper, cardNumber);
                            feed.insertAdjacentHTML('beforeend', cardHtml);
                        });
                        
                        // Set up observers for new cards
                        const newCards = feed.querySelectorAll('.paper-card:not([data-observed])');
                        newCards.forEach(card => {
                            card.setAttribute('data-observed', 'true');
                            observer.observe(card);
                        });
                        
                        // Reset button state
                        btn.disabled = false;
                        btnText.textContent = 'Load More Papers';
                        btnIcon.textContent = '‚Üì';
                        btnIcon.style.animation = '';
                        
                        console.log(`Loaded ${data.papers.length} new papers`);
                    } else {
                        // No more papers
                        btnText.textContent = 'No More Papers';
                        btnIcon.textContent = '‚úì';
                        btnIcon.style.animation = '';
                        setTimeout(() => {
                            btn.disabled = false;
                            btnText.textContent = 'Load More Papers';
                            btnIcon.textContent = '‚Üì';
                        }, 2000);
                    }
                    
                    // Save state after loading more papers
                    savePageState();
                } catch (error) {
                    console.error('Error loading more papers:', error);
                    btn.disabled = false;
                    btnText.textContent = 'Error - Try Again';
                    btnIcon.textContent = '‚ö†';
                    btnIcon.style.animation = '';
                    setTimeout(() => {
                        btnText.textContent = 'Load More Papers';
                        btnIcon.textContent = '‚Üì';
                    }, 3000);
                }
            }
        </script>

        <!-- Paper Sidebar -->
        <div id="paperSidebar" class="paper-sidebar">
            <div class="sidebar-header">
                <h3 id="sidebarTitle" class="sidebar-title">Loading...</h3>
                <button class="sidebar-close" onclick="closeSidebar()">&times;</button>
            </div>
            <iframe id="paperFrame" class="sidebar-iframe"></iframe>
        </div>
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>


        {% if error %}
        <div class="error-banner">
            <div class="error-icon">!</div>
            <div class="error-content">
                <h3>Unable to Load Papers</h3>
                <p>{{ error }}</p>
                <button onclick="location.reload()" class="retry-btn">Retry</button>
            </div>
        </div>
        {% endif %}

        {% if info_message %}
        <div class="info-banner">
            <div class="info-content">
                <p>{{ info_message }}</p>
            </div>
        </div>
        {% endif %}

        {% if using_recommendations %}
        <div class="recommendations-banner">
            <div class="banner-icon">*</div>
            <div class="banner-content">
                <h3>Personalized Recommendations</h3>
                <p>These papers are recommended based on your liked papers</p>
            </div>
        </div>
        {% endif %}

        <div class="feed" id="feedContainer">
            {% for paper in papers[:20] %}
            <article class="paper-card" data-card-number="{{ loop.index }}" data-paper-id="{{ paper.paperId }}" data-paper-json='{{ paper | tojson | safe }}'>
                <div class="card-header">
                    <div class="paper-meta">
                        <h2 class="paper-title">{{ paper.title | safe }}</h2>
                        <div class="paper-info">
                            {% if paper.authors %}
                            <span class="authors">
                                {% if paper.authors|length <= 4 %}
                                    {# Show all authors if 4 or fewer #}
                                    {% for author in paper.authors %}
                                        {{ author.name }}{% if not loop.last %}, {% endif %}
                                    {% endfor %}
                                {% else %}
                                    {# Show first 2 and last 2 if more than 4 #}
                                    {{ paper.authors[0].name }}, {{ paper.authors[1].name }}, ... {{ paper.authors[-2].name }}, {{ paper.authors[-1].name }}
                                {% endif %}
                            </span>
                            {% endif %}
                            <span class="separator">‚Ä¢</span>
                            <span class="year">{{ paper.year }}</span>
                            {% if paper.venue %}
                            <span class="separator">‚Ä¢</span>
                            <span class="venue">{{ paper.venue }}</span>
                            {% endif %}
                            {% if paper.citationCount > 0 %}
                            <span class="separator">‚Ä¢</span>
                            <span class="citations">{{ paper.citationCount }} citations</span>
                            {% endif %}
                        </div>
                    </div>
                </div>

                {% if paper.tldr %}
                <div class="paper-tldr">
                    <strong>TL;DR:</strong> {{ paper.tldr | safe }}
                </div>
                {% endif %}

                <div class="paper-abstract-container">
                    <button class="abstract-toggle" onclick="toggleAbstract('{{ paper.paperId }}')">
                        <span class="toggle-icon">‚ñ∂</span>
                        <span class="toggle-text">Abstract</span>
                    </button>
                    <div class="paper-abstract" id="abstract-{{ paper.paperId }}" style="display: none;">
                        {% if paper.abstract %}
                            {{ paper.abstract | safe }}
                        {% else %}
                            <em class="no-abstract">No abstract available</em>
                        {% endif %}
                    </div>
                </div>

                <div class="card-footer">
                    {% if paper.url %}
                    {% if paper.source == 'bioRxiv' %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on bioRxiv</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% elif paper.source == 'OpenAlex' %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on publisher's page</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% else %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on Semantic Scholar</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% endif %}
                    {% endif %}
                    <div class="card-actions">
                        <button class="like-btn" onclick="likePaper('{{ paper.paperId }}', event)" title="Like this paper">
                            <span class="like-text">Like</span>
                        </button>
                        <button class="dislike-btn" onclick="dislikePaper('{{ paper.paperId }}', event)" title="Dislike this paper">
                            <span class="dislike-text">Pass</span>
                        </button>
                    </div>
                </div>
            </article>
            {% endfor %}
        </div>

        {% if not papers %}
        <div class="empty-state">
            {% if not topics and not authors %}
            <div class="empty-icon">‚Üí</div>
            <h2>Start Your Research Journey</h2>
            <p>Enter your research interests above to generate a personalized feed of papers</p>
            {% else %}
            <div class="empty-icon">?</div>
            <h2>No papers found</h2>
            <p>Try adjusting your search topics</p>
            {% endif %}
        </div>
        {% endif %}
    </div>

    <!-- Load More Button - outside the collapsible feed -->
    {% if papers %}
    <div class="load-more-container" id="loadMoreContainer">
        <button onclick="loadMorePapers()" class="load-more-btn" id="loadMoreBtn">
            <span class="load-more-text">Load More Papers</span>
            <span class="load-more-icon">‚Üì</span>
        </button>
    </div>
    {% endif %}

    <!-- Clear Feedback Modal -->
    <div id="clearModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Clear Feedback</h3>
                <button class="modal-close" onclick="closeClearModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>What would you like to clear?</p>
                <div class="modal-actions">
                    <form method="POST" action="/feedback/clear/liked" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-liked-btn">
                            Clear Liked ({{ feedback.liked|length if feedback else 0 }})
                        </button>
                    </form>
                    <form method="POST" action="/feedback/clear/disliked" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-disliked-btn">
                            Clear Disliked ({{ feedback.disliked|length if feedback else 0 }})
                        </button>
                    </form>
                    <form method="POST" action="/feedback/clear" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-all-btn">
                            Clear All Feedback
                        </button>
                    </form>
                </div>
                <button onclick="closeClearModal()" class="modal-btn cancel-btn">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
