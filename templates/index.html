<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Doomscroll</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <!-- Initial Page Loading Spinner -->
    <div id="pageLoader" class="page-loader">
        <div class="loader-content">
            <div class="spinner"></div>
            <p class="loader-text">Loading Research Doomscroll...</p>
        </div>
    </div>

    <!-- Feed Generation Loading Overlay -->
    <div id="feedLoader" class="feed-loader hidden">
        <div class="loader-content">
            <div class="spinner"></div>
            <p class="loader-text">Generating your feed...</p>
        </div>
    </div>

    <div class="container">
        <header class="header">
            <div class="header-top">
                <div class="header-title">
                    <h1>Research Doomscroll</h1>
                    <p class="subtitle">Infinite scroll through research papers</p>
                </div>
                <div class="header-actions">
                    {% if user and user.id != 'anonymous' %}
                        <div class="user-info">
                            <img src="{{ user.picture }}" alt="{{ user.name }}" class="user-avatar">
                            <span class="user-name">Welcome {{ user.name.split()[0] if user.name else user.email.split('@')[0] }}</span>
                            <a href="/logout" class="btn-logout">Logout</a>
                        </div>
                    {% else %}
                        <a href="/login" class="btn-login">Sign in with Google</a>
                    {% endif %}
                </div>
            </div>
        </header>
        
        <!-- Navigation Menu - Separate sticky element -->
        <nav class="nav-menu">
            <a href="javascript:void(0)" onclick="showSearchForm(); return false;" class="nav-item active">Search</a>
            <div class="nav-item-dropdown">
                <a href="/likes" class="nav-item" onclick="savePageState()">Folders</a>
                <div class="dropdown-menu">
                    <a href="/likes" class="dropdown-item" onclick="savePageState()">Likes</a>
                </div>
            </div>
            <a href="#Following" class="nav-item">Following</a>
            <a href="#Recommended" class="nav-item">Recommended</a>
            <a href="#Contact" class="nav-item">Contact</a>
        </nav>
            
            {% if show_form %}
            <div class="search-form-wrapper" id="searchFormWrapper">
                <form class="search-form" method="POST" action="/profile/save" onsubmit="showFeedLoader()">

                <div class="form-group">
                    <label for="topics">
                        Topics & Keywords
                    </label>
                    <input 
                        type="text" 
                        id="topics" 
                        name="topics" 
                        placeholder="e.g., machine learning, neural networks, dopamine"
                        value="{{ topics }}"
                        class="form-input"
                    >
                    <span class="help-text">Enter research topics or keywords separated by commas</span>
                </div>
                
                <div class="form-group">
                    <label for="authors">
                        Authors
                    </label>
                    <input 
                        type="text" 
                        id="authors" 
                        name="authors" 
                        placeholder="e.g., Samay R. Shah, Michael J Iadarola"
                        value="{{ authors }}"
                        class="form-input"
                    >
                    <span class="help-text">Enter author names separated by commas (optional)</span>
                </div>
                
                <div class="form-group">
                    <label for="sort_by">
                        Sort By
                    </label>
                    <select id="sort_by" name="sort_by" class="form-input">
                        <option value="recency" {% if sort_by == 'recency' or not sort_by %}selected{% endif %}>Recency (Newest First)</option>
                        <option value="relevance" {% if sort_by == 'relevance' %}selected{% endif %}>Relevance (Most Cited)</option>
                    </select>
                    <span class="help-text">Choose how to order the results</span>
                </div>
                
                <div class="form-actions">
                    <button type="submit" class="search-btn">
                        <span>Save Profile & Generate Feed</span>
                    </button>
                    {% if profile.topics %}
                    <form method="POST" action="/profile/clear" style="display: inline;">
                        <button type="submit" class="clear-btn">Clear Profile</button>
                    </form>
                    {% endif %}
                </div>
            </form>
            </div>
            {% endif %}
        </header>

    <script>
        // Store search parameters from the server
        const CURRENT_TOPICS = "{{ topics if topics else '' }}";
        const CURRENT_AUTHORS = "{{ authors if authors else '' }}";
        const USE_RECOMMENDATIONS = {{ 'true' if using_recommendations is defined and using_recommendations else 'false' }};
        
        console.log('Search params loaded:', { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS, useRec: USE_RECOMMENDATIONS });
        
        // Track liked and disliked papers
        let likedPapers = new Set({{ feedback.liked | tojson }});
        let dislikedPapers = new Set({{ feedback.disliked | tojson }});

        // Track which cards have been logged as visible
            const loggedCards = new Set();
            
            // Global observer for visibility tracking
            let observer = null;

        // ============= CACHE MANAGEMENT =============
        const CACHE_KEY = 'research_doomscroll_cache';
        const CACHE_VERSION = '1.0';
        const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

        function savePageState() {
            try {
                const feed = document.querySelector('.feed');
                if (!feed) {
                    console.log('‚ö†Ô∏è  Cannot save: No feed element found');
                    return;
                }

                // Collect all paper cards data
                const papers = [];
                document.querySelectorAll('.paper-card').forEach(card => {
                    const paperJson = card.getAttribute('data-paper-json');
                    if (paperJson) {
                        papers.push(JSON.parse(paperJson));
                    }
                });

                // Track which abstracts are expanded
                const expandedAbstracts = [];
                document.querySelectorAll('.abstract-content').forEach(abstract => {
                    if (abstract.style.display !== 'none') {
                        const paperId = abstract.id.replace('abstract-', '');
                        expandedAbstracts.push(paperId);
                    }
                });

                const state = {
                    version: CACHE_VERSION,
                    timestamp: Date.now(),
                    scrollPosition: window.scrollY,
                    searchParams: {
                        topics: CURRENT_TOPICS,
                        authors: CURRENT_AUTHORS,
                        useRecommendations: USE_RECOMMENDATIONS
                    },
                    papers: papers,
                    expandedAbstracts: expandedAbstracts,
                    likedPapers: Array.from(likedPapers),
                    dislikedPapers: Array.from(dislikedPapers)
                };

                localStorage.setItem(CACHE_KEY, JSON.stringify(state));
                console.log('üíæ CACHE SAVED:', {
                    papers: papers.length,
                    expandedAbstracts: expandedAbstracts.length,
                    scrollPosition: window.scrollY,
                    searchParams: state.searchParams,
                    timestamp: new Date(state.timestamp).toLocaleTimeString()
                });
            } catch (error) {
                console.error('‚ùå Error saving page state:', error);
            }
        }

        function loadPageState() {
            try {
                const cached = localStorage.getItem(CACHE_KEY);
                if (!cached) {
                    console.log('üìÇ No cache found in localStorage');
                    return null;
                }

                const state = JSON.parse(cached);
                
                console.log('üìÇ CACHE FOUND:', {
                    version: state.version,
                    papers: state.papers.length,
                    timestamp: new Date(state.timestamp).toLocaleTimeString(),
                    age: Math.round((Date.now() - state.timestamp) / 1000 / 60) + ' minutes old',
                    searchParams: state.searchParams
                });
                
                // Check cache version and expiry
                if (state.version !== CACHE_VERSION) {
                    console.log('‚ö†Ô∏è  Cache version mismatch (expected:', CACHE_VERSION, 'got:', state.version, '), clearing cache');
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }

                if (Date.now() - state.timestamp > CACHE_EXPIRY) {
                    console.log('‚è∞ Cache expired (age:', Math.round((Date.now() - state.timestamp) / 1000 / 60 / 60), 'hours), clearing cache');
                    localStorage.removeItem(CACHE_KEY);
                    return null;
                }

                console.log('‚úÖ Cache is valid and will be considered for restore');
                return state;
            } catch (error) {
                console.error('‚ùå Error loading page state:', error);
                return null;
            }
        }

        function clearPageCache() {
            localStorage.removeItem(CACHE_KEY);
            console.log('üóëÔ∏è  CACHE CLEARED - New search initiated');
        }

        function restorePageState(state) {
            if (!state || !state.papers || state.papers.length === 0) {
                console.log('‚ö†Ô∏è  Cannot restore: No papers in cached state');
                return false;
            }

            // Check if we're on the same search
            const sameSearch = state.searchParams.topics === CURRENT_TOPICS &&
                             state.searchParams.authors === CURRENT_AUTHORS;
            
            console.log('üîç SEARCH COMPARISON:', {
                cached: state.searchParams,
                current: { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS },
                sameSearch: sameSearch
            });
            
            if (!sameSearch) {
                console.log('üîÑ Different search parameters detected, NOT restoring cache');
                clearPageCache();
                return false;
            }

            const feed = document.querySelector('.feed');
            if (!feed) {
                console.log('‚ö†Ô∏è  Cannot restore: No feed element found');
                return false;
            }

            console.log('üîÑ RESTORING CACHE:', state.papers.length, 'papers');

            // Build HTML for cached papers
            let html = '';
            state.papers.forEach((paper, index) => {
                const cardNumber = index + 1;
                const isExpanded = state.expandedAbstracts.includes(paper.paperId);
                
                // Format authors properly
                let authorsHtml = '';
                if (paper.authors && Array.isArray(paper.authors)) {
                    if (paper.authors.length <= 4) {
                        authorsHtml = paper.authors.map(a => a.name || a).join(', ');
                    } else {
                        const first = paper.authors[0].name || paper.authors[0];
                        const second = paper.authors[1].name || paper.authors[1];
                        const secondLast = paper.authors[paper.authors.length - 2].name || paper.authors[paper.authors.length - 2];
                        const last = paper.authors[paper.authors.length - 1].name || paper.authors[paper.authors.length - 1];
                        authorsHtml = `${first}, ${second}, ... ${secondLast}, ${last}`;
                    }
                } else if (typeof paper.authors === 'string') {
                    authorsHtml = paper.authors;
                }
                
                html += `
                <article class="paper-card" data-card-number="${cardNumber}" data-paper-id="${paper.paperId}" data-paper-json='${JSON.stringify(paper).replace(/'/g, "&apos;")}'>
                    <div class="card-header">
                        <div class="paper-meta">
                            <h2 class="paper-title">${paper.title}</h2>
                            <div class="paper-info">
                                ${authorsHtml ? `<span class="authors">${authorsHtml}</span>` : ''}
                                <span class="separator">‚Ä¢</span>
                                <span class="year">${paper.year || ''}</span>
                                ${paper.venue ? `<span class="separator">‚Ä¢</span><span class="venue">${paper.venue}</span>` : ''}
                                ${paper.citationCount > 0 ? `<span class="separator">‚Ä¢</span><span class="citations">${paper.citationCount} citations</span>` : ''}
                            </div>
                        </div>
                    </div>
                    
                    ${paper.tldr ? `
                    <div class="paper-tldr">
                        <strong>TL;DR:</strong> ${paper.tldr}
                    </div>
                    ` : ''}
                    
                    <div class="paper-abstract-container">
                        <button class="abstract-toggle" onclick="toggleAbstract('${paper.paperId}')">
                            <span class="toggle-icon">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>
                            <span class="toggle-text">Abstract</span>
                        </button>
                        <div class="paper-abstract" id="abstract-${paper.paperId}" style="display: ${isExpanded ? 'block' : 'none'};">
                            ${paper.abstract ? paper.abstract : '<em class="no-abstract">No abstract available</em>'}
                        </div>
                    </div>

                    <div class="card-footer">
                        ${paper.url ? `
                        <a href="${paper.url}" class="paper-link" target="_blank" rel="noopener noreferrer">
                            <span>${paper.source === 'bioRxiv' ? 'Read on bioRxiv' : 'Read on publisher\'s page'}</span>
                            <span class="link-icon">‚Üó</span>
                        </a>
                        ` : ''}
                        <div class="card-actions">
                            <button class="like-btn" onclick="likePaper('${paper.paperId}', event)" title="Like this paper">
                                <span class="like-text">Like</span>
                            </button>
                            <button class="dislike-btn" onclick="dislikePaper('${paper.paperId}', event)" title="Dislike this paper">
                                <span class="dislike-text">Pass</span>
                            </button>
                        </div>
                    </div>
                </article>
                `;
            });

            feed.innerHTML = html;

            // Restore feedback state UI
            state.likedPapers.forEach(paperId => {
                const btn = document.querySelector(`[onclick*="${paperId}"]`)?.closest('.card-actions')?.querySelector('.like-btn');
                if (btn) {
                    btn.classList.add('active');
                    btn.querySelector('.like-text').textContent = 'Liked!';
                }
            });

            state.dislikedPapers.forEach(paperId => {
                const btn = document.querySelector(`[onclick*="${paperId}"]`)?.closest('.card-actions')?.querySelector('.dislike-btn');
                if (btn) {
                    btn.classList.add('active');
                    const card = btn.closest('.paper-card');
                    card.style.opacity = '0.3';
                    card.style.transform = 'translateX(-20px)';
                }
            });

            // Re-setup observers for restored cards
            document.querySelectorAll('.paper-card').forEach(card => {
                if (observer) {
                    observer.observe(card);
                }
            });

            console.log('‚ú® RESTORE COMPLETE:', state.papers.length, 'papers restored');
            
            // Restore scroll position after DOM is fully rendered
            // Try immediately, then retry after animations complete
            const targetScrollPos = state.scrollPosition;
            
            // Immediate attempt
            setTimeout(() => {
                window.scrollTo(0, targetScrollPos);
                console.log('üìç Scroll position restored (1st attempt):', targetScrollPos);
            }, 100);
            
            // Retry after page fully renders (accounts for images, etc.)
            setTimeout(() => {
                window.scrollTo(0, targetScrollPos);
                console.log('üìç Scroll position restored (2nd attempt):', targetScrollPos);
            }, 500);

            return true;
        }

        // Auto-save state before leaving page
        window.addEventListener('beforeunload', () => {
            savePageState();
        });

        // Auto-save state periodically (every 30 seconds)
        setInterval(() => {
            savePageState();
        }, 30000);

        // Save state when scrolling stops
        let scrollSaveTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(() => {
                savePageState();
            }, 1000);
        }, { passive: true });

        // Save state when liking/disliking papers
        const originalLikePaper = likePaper;
        const originalDislikePaper = dislikePaper;

            // Page load initialization
            window.addEventListener('DOMContentLoaded', function() {
                console.log('üöÄ PAGE LOAD - Checking for cache...');
                console.log('üìã Current search params:', { topics: CURRENT_TOPICS, authors: CURRENT_AUTHORS });
                
                // Try to restore from cache first
                const cachedState = loadPageState();
                let restoredFromCache = false;
                
                if (cachedState && cachedState.papers && cachedState.papers.length > 0) {
                    const serverPaperCount = {{ papers|length if papers else 0 }};
                    
                    console.log('üîç RESTORE DECISION:', {
                        serverPaperCount: serverPaperCount,
                        cachedPaperCount: cachedState.papers.length,
                        decision: cachedState.papers.length >= serverPaperCount ? 'RESTORE CACHE' : 'USE SERVER DATA'
                    });
                    
                    // Prefer cache if it has same or more papers (means we loaded more)
                    // This way returning from /likes will restore your full feed
                    if (cachedState.papers.length >= serverPaperCount) {
                        restoredFromCache = restorePageState(cachedState);
                    } else {
                        console.log('üìÑ Server has more papers, using fresh server data');
                    }
                } else {
                    console.log('üìÑ No valid cache to restore, using server data');
                }

                // Hide initial page loader
                const pageLoader = document.getElementById('pageLoader');
                if (pageLoader) {
                    setTimeout(() => {
                        pageLoader.classList.add('hidden');
                        setTimeout(() => {
                            pageLoader.style.display = 'none';
                        }, 300);
                    }, restoredFromCache ? 200 : 500); // Faster if restoring from cache
                }

                // Don't auto-collapse - keep form visible so users can always access it

                // Mark already rated papers (if not restored from cache)
                if (!restoredFromCache) {
                    likedPapers.forEach(paperId => {
                        const btn = document.querySelector(`[onclick*="${paperId}"]`)?.closest('.card-actions')?.querySelector('.like-btn');
                        if (btn) {
                            btn.classList.add('active');
                            btn.querySelector('.like-text').textContent = 'Liked!';
                        }
                    });

                    dislikedPapers.forEach(paperId => {
                        const btn = document.querySelector(`[onclick*="${paperId}"]`)?.closest('.card-actions')?.querySelector('.dislike-btn');
                        if (btn) {
                            const card = btn.closest('.paper-card');
                            card.style.opacity = '0.3';
                        }
                    });
                }

                // Set up Intersection Observer to track card visibility
                const observerOptions = {
                    root: null, // viewport
                    rootMargin: '0px',
                    threshold: 0.75 // 75% visible (more lenient for mobile)
                };

                observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && entry.intersectionRatio >= 0.75) {
                            const card = entry.target;
                            const cardNumber = card.dataset.cardNumber;
                            const paperId = card.dataset.paperId;
                            
                            // Use paper ID as unique identifier to avoid conflicts with restarted numbering
                            if (!loggedCards.has(paperId)) {
                                loggedCards.add(paperId);
                                logCardVisible(cardNumber, paperId);
                                
                                // Check if this is the second-to-last card
                                const allCards = document.querySelectorAll('.paper-card');
                                const currentIndex = Array.from(allCards).indexOf(card);
                                if (currentIndex === allCards.length - 2) {
                                    console.log(`üîî SECOND-TO-LAST CARD: Viewing card #${cardNumber} (${currentIndex + 1} of ${allCards.length}) - Auto-loading more papers...`);
                                    logSecondToLastCard(cardNumber, paperId, allCards.length);
                                    
                                    // Automatically trigger load more papers
                                    const loadMoreBtn = document.getElementById('loadMoreBtn');
                                    if (loadMoreBtn && !loadMoreBtn.disabled) {
                                        console.log('üîÑ Auto-triggering "Load More Papers"...');
                                        loadMorePapers();
                                    }
                                }
                            }
                        }
                    });
                }, observerOptions);

                // Observe all paper cards
                document.querySelectorAll('.paper-card').forEach(card => {
                    observer.observe(card);
                });

                // Auto-hide/show header on scroll
                let lastScrollTop = 0;
                let scrollTimeout;
                const header = document.querySelector('.header');
                const scrollThreshold = 150; // Minimum scroll distance to trigger hide
                const showThreshold = 80; // Minimum scroll-up distance to show header
                
                window.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    
                    scrollTimeout = setTimeout(function() {
                        let scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        let scrollDelta = scrollTop - lastScrollTop;
                        
                        if (scrollDelta > 5 && scrollTop > scrollThreshold) {
                            // Scrolling down & past threshold
                            header.classList.add('header-hidden');
                        } else if (scrollDelta < -showThreshold) {
                            // Scrolling up at least 80px
                            header.classList.remove('header-hidden');
                        } else if (scrollTop <= 0) {
                            // At top of page
                            header.classList.remove('header-hidden');
                        }
                        
                        lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
                    }, 20); // Reduced debounce for more responsive feel
                }, { passive: true });
            });

            async function logCardVisible(cardNumber, paperId) {
                try {
                    const formData = new FormData();
                    formData.append('card_number', cardNumber);
                    formData.append('paper_id', paperId);
                    
                    await fetch('/card/visible', {
                        method: 'POST',
                        body: formData
                    });
                } catch (error) {
                    console.error('Error logging card visibility:', error);
                }
            }

            async function logSecondToLastCard(cardNumber, paperId, totalCards) {
                try {
                    const formData = new FormData();
                    formData.append('card_number', cardNumber);
                    formData.append('paper_id', paperId);
                    formData.append('total_cards', totalCards);
                    
                    await fetch('/card/second-to-last', {
                        method: 'POST',
                        body: formData
                    });
                } catch (error) {
                    console.error('Error logging second-to-last card:', error);
                }
            }

            function updateFeedbackStats() {
                const likedCountEl = document.getElementById('likedCount');
                const dislikedCountEl = document.getElementById('dislikedCount');
                
                if (likedCountEl) likedCountEl.textContent = likedPapers.size;
                if (dislikedCountEl) dislikedCountEl.textContent = dislikedPapers.size;
            }

            function showFeedLoader() {
                // Only clear cache if search params are actually changing
                const form = document.querySelector('.search-form');
                const newTopics = form.querySelector('#topics').value.trim();
                const newAuthors = form.querySelector('#authors').value.trim();
                
                const searchChanged = newTopics !== CURRENT_TOPICS || newAuthors !== CURRENT_AUTHORS;
                
                console.log('üîç SEARCH SUBMISSION:', {
                    currentTopics: CURRENT_TOPICS,
                    currentAuthors: CURRENT_AUTHORS,
                    newTopics: newTopics,
                    newAuthors: newAuthors,
                    searchChanged: searchChanged
                });
                
                if (searchChanged) {
                    clearPageCache();
                } else {
                    console.log('üìå Same search parameters, keeping cache');
                }
                
                const feedLoader = document.getElementById('feedLoader');
                if (feedLoader) {
                    feedLoader.classList.remove('hidden');
                }
                
                // Hide search form after submission
                const wrapper = document.getElementById('searchFormWrapper');
                if (wrapper) {
                    setTimeout(() => {
                        wrapper.classList.add('hidden');
                    }, 300);
                }
            }
            
            function showSearchForm() {
                const wrapper = document.getElementById('searchFormWrapper');
                
                // If wrapper doesn't exist, we're on a different page - navigate to home
                if (!wrapper) {
                    window.location.href = '/?show_form_only=true';
                    return;
                }
                
                // Show the form if we're already on the home page
                if (wrapper) {
                    wrapper.classList.remove('hidden');
                    
                    // Get the nav menu height to offset the scroll
                    const navMenu = document.querySelector('.nav-menu');
                    const navHeight = navMenu ? navMenu.offsetHeight : 0;
                    
                    // Scroll to the form with offset for sticky nav
                    setTimeout(() => {
                        const wrapperTop = wrapper.getBoundingClientRect().top + window.pageYOffset;
                        const offsetPosition = wrapperTop - navHeight;
                        
                        window.scrollTo({
                            top: offsetPosition,
                            behavior: 'smooth'
                        });
                    }, 100); // Small delay to ensure the wrapper is visible
                }
                
                console.log('üìù Search form shown (no auto-search)');
            }
            
            // Hide form on page load if there are papers
            document.addEventListener('DOMContentLoaded', function() {
                const wrapper = document.getElementById('searchFormWrapper');
                // Check if there are papers in the feed
                const papers = {{ papers | tojson | safe }};
                
                if (papers && papers.length > 0 && wrapper) {
                    // Add a small delay to ensure smooth transition
                    setTimeout(() => {
                        wrapper.classList.add('hidden');
                    }, 100);
                }
            });

        function toggleFeed() {
            const feedContainer = document.getElementById('feedContainer');
            const icon = document.getElementById('feedToggleIcon');
            const toggleBtn = document.getElementById('feedToggleBtn');
            const loadMoreContainer = document.getElementById('loadMoreContainer');
            
            feedContainer.classList.toggle('collapsed');
            
            if (feedContainer.classList.contains('collapsed')) {
                icon.textContent = '‚ñ∂';
                toggleBtn.classList.add('collapsed');
                if (loadMoreContainer) loadMoreContainer.style.display = 'none';
            } else {
                icon.textContent = '‚ñº';
                toggleBtn.classList.remove('collapsed');
                if (loadMoreContainer) loadMoreContainer.style.display = 'flex';
            }
        }

        function toggleFilters() {
            const filtersContent = document.getElementById('filtersContent');
            const icon = document.getElementById('filterToggleIcon');
            const toggleBtn = document.getElementById('filterToggleBtn');
            
            filtersContent.classList.toggle('collapsed');
            
            if (filtersContent.classList.contains('collapsed')) {
                icon.textContent = '‚ñ∂';
                toggleBtn.classList.add('collapsed');
            } else {
                icon.textContent = '‚ñº';
                toggleBtn.classList.remove('collapsed');
            }
        }

        async function likePaper(paperId, event) {
                try {
                    const btn = event.target.closest('.like-btn');
                    const card = btn.closest('.paper-card');
                    
                    // Check if already liked - if so, unlike it
                    if (likedPapers.has(paperId)) {
                        // Unlike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        const response = await fetch('/paper/unlike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            likedPapers.delete(paperId);
                            btn.classList.remove('active');
                            btn.querySelector('.like-text').textContent = 'Like';
                            btn.disabled = false;
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    } else {
                        // Like the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        // Get paper data from card
                        const paperJson = card.getAttribute('data-paper-json');
                        if (paperJson) {
                            formData.append('paper_data', paperJson);
                        }
                        
                        const response = await fetch('/paper/like', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            // Remove from disliked if present
                            if (dislikedPapers.has(paperId)) {
                                dislikedPapers.delete(paperId);
                            }
                            
                            likedPapers.add(paperId);
                            btn.classList.add('active');
                            btn.querySelector('.like-text').textContent = 'Liked!';
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    }
                } catch (error) {
                    console.error('Error with like/unlike:', error);
                }
            }

            async function dislikePaper(paperId, event) {
                try {
                    const btn = event.target.closest('.dislike-btn');
                    const card = btn.closest('.paper-card');
                    
                    // Check if already disliked - if so, undislike it
                    if (dislikedPapers.has(paperId)) {
                        // Undislike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        const response = await fetch('/paper/undislike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            dislikedPapers.delete(paperId);
                            btn.classList.remove('active');
                            card.style.opacity = '1';
                            card.style.transform = 'translateX(0)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    } else {
                        // Dislike the paper
                        const formData = new FormData();
                        formData.append('paper_id', paperId);
                        
                        // Get paper data from card
                        const paperJson = card.getAttribute('data-paper-json');
                        if (paperJson) {
                            formData.append('paper_data', paperJson);
                        }
                        
                        const response = await fetch('/paper/dislike', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        if (result.status === 'success') {
                            // Remove from liked if present
                            if (likedPapers.has(paperId)) {
                                likedPapers.delete(paperId);
                                const likeBtn = card.querySelector('.like-btn');
                                if (likeBtn) {
                                    likeBtn.classList.remove('active');
                                    likeBtn.querySelector('.like-text').textContent = 'Like';
                                }
                            }
                            
                            dislikedPapers.add(paperId);
                            btn.classList.add('active');
                            card.style.opacity = '0.3';
                            card.style.transform = 'translateX(-20px)';
                            updateFeedbackStats();
                            savePageState(); // Save state after feedback change
                        }
                    }
                } catch (error) {
                    console.error('Error with dislike/undislike:', error);
                }
            }

            function toggleAbstract(paperId) {
                const abstractDiv = document.getElementById(`abstract-${paperId}`);
                const toggleButton = abstractDiv.parentElement.querySelector('.abstract-toggle');
                const icon = toggleButton.querySelector('.toggle-icon');
                
                if (abstractDiv.style.display === 'none') {
                    abstractDiv.style.display = 'block';
                    icon.textContent = '‚ñº';
                    toggleButton.classList.add('expanded');
                } else {
                    abstractDiv.style.display = 'none';
                    icon.textContent = '‚ñ∂';
                    toggleButton.classList.remove('expanded');
                }
                
                // Save state after toggling abstract
                savePageState();
            }

            function showClearModal() {
                document.getElementById('clearModal').style.display = 'flex';
            }

            function closeClearModal() {
                document.getElementById('clearModal').style.display = 'none';
            }

            // Close modal when clicking outside
            window.onclick = function(event) {
                const modal = document.getElementById('clearModal');
                if (event.target === modal) {
                    closeClearModal();
                }
            }

            function openSidebar(url, title) {
                const sidebar = document.getElementById('paperSidebar');
                const iframe = document.getElementById('paperFrame');
                const titleEl = document.getElementById('sidebarTitle');
                const overlay = document.getElementById('sidebarOverlay');
                
                // Use our proxy to bypass X-Frame-Options
                const proxyUrl = `/proxy?url=${encodeURIComponent(url)}`;
                
                titleEl.textContent = title;
                iframe.src = proxyUrl;
                sidebar.classList.add('active');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeSidebar() {
                const sidebar = document.getElementById('paperSidebar');
                const iframe = document.getElementById('paperFrame');
                const overlay = document.getElementById('sidebarOverlay');
                
                sidebar.classList.remove('active');
                overlay.classList.remove('active');
                iframe.src = '';
                document.body.style.overflow = 'auto';
            }

            async function loadMorePapers() {
                const btn = document.getElementById('loadMoreBtn');
                const btnText = btn.querySelector('.load-more-text');
                const btnIcon = btn.querySelector('.load-more-icon');
                
                // Show loading state
                btn.disabled = true;
                btnText.textContent = 'Loading...';
                btnIcon.textContent = '‚ü≥';
                btnIcon.style.animation = 'spin 1s linear infinite';
                
                try {
                    // Use the stored search parameters instead of URL params
                    const topics = CURRENT_TOPICS;
                    const authors = CURRENT_AUTHORS;
                    const useRecommendations = USE_RECOMMENDATIONS;
                    
                    // Build the API URL
                    let apiUrl = '/api/load-more?';
                    if (topics) apiUrl += `topics=${encodeURIComponent(topics)}&`;
                    if (authors) apiUrl += `authors=${encodeURIComponent(authors)}&`;
                    if (useRecommendations) apiUrl += `use_recommendations=${useRecommendations}&`;
                    
                    console.log('Load More API URL:', apiUrl);
                    
                    // Fetch new papers
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    
                    console.log('Load More Response:', data);
                    console.log('Papers count:', data.papers ? data.papers.length : 0);
                    console.log('From cache:', data.from_cache);
                    
                    if (data.papers && data.papers.length > 0) {
                        // Get the feed container
                        const feed = document.querySelector('.feed');
                        
                        console.log('Feed element found:', !!feed);
                        
                        // Restart numbering from 1 for each load more batch
                        // Append each new paper
                        data.papers.forEach((paper, index) => {
                            const cardNumber = index + 1;  // Restart from 1 each time
                            const cardHtml = createPaperCard(paper, cardNumber);
                            feed.insertAdjacentHTML('beforeend', cardHtml);
                        });
                        
                        // Set up observers for new cards
                        const newCards = feed.querySelectorAll('.paper-card:not([data-observed])');
                        newCards.forEach(card => {
                            card.setAttribute('data-observed', 'true');
                            observer.observe(card);
                        });
                        
                        // Reset button state
                        btn.disabled = false;
                        btnText.textContent = 'Load More Papers';
                        btnIcon.textContent = '‚Üì';
                        btnIcon.style.animation = '';
                        
                        console.log(`Loaded ${data.papers.length} new papers`);
                    } else {
                        // No more papers
                        btnText.textContent = 'No More Papers';
                        btnIcon.textContent = '‚úì';
                        btnIcon.style.animation = '';
                        setTimeout(() => {
                            btn.disabled = false;
                            btnText.textContent = 'Load More Papers';
                            btnIcon.textContent = '‚Üì';
                        }, 2000);
                    }
                    
                    // Save state after loading more papers
                    savePageState();
                } catch (error) {
                    console.error('Error loading more papers:', error);
                    btn.disabled = false;
                    btnText.textContent = 'Error - Try Again';
                    btnIcon.textContent = '‚ö†';
                    btnIcon.style.animation = '';
                    setTimeout(() => {
                        btnText.textContent = 'Load More Papers';
                        btnIcon.textContent = '‚Üì';
                    }, 3000);
                }
            }

            function createPaperCard(paper, cardNumber) {
                const isLiked = likedPapers.has(paper.paperId);
                const isDisliked = dislikedPapers.has(paper.paperId);
                
                const authorsHtml = paper.authors && paper.authors.length > 0 
                    ? `<span class="authors">
                        ${paper.authors.slice(0, 3).map(a => a.name).join(', ')}
                        ${paper.authors.length > 3 ? `<span class="more-authors">+${paper.authors.length - 3} more</span>` : ''}
                       </span>
                       <span class="separator">‚Ä¢</span>`
                    : '';
                
                const venueHtml = paper.venue 
                    ? `<span class="separator">‚Ä¢</span><span class="venue">${paper.venue}</span>`
                    : '';
                
                const citationsHtml = paper.citationCount > 0 
                    ? `<span class="separator">‚Ä¢</span><span class="citations">${paper.citationCount} citations</span>`
                    : '';
                
                const tldrHtml = paper.tldr 
                    ? `<div class="paper-tldr"><strong>TL;DR:</strong> ${paper.tldr}</div>`
                    : '';
                
                const linkText = paper.source === 'bioRxiv' ? 'Read on bioRxiv' : 'Read on Semantic Scholar';
                
                return `
                    <article class="paper-card" data-card-number="${cardNumber}" data-paper-id="${paper.paperId}">
                        <div class="card-header">
                            <div class="paper-meta">
                                <h2 class="paper-title">${paper.title}</h2>
                                <div class="paper-info">
                                    ${authorsHtml}
                                    <span class="year">${paper.year}</span>
                                    ${venueHtml}
                                    ${citationsHtml}
                                    <span class="separator">‚Ä¢</span>
                                    <span class="source-badge">${paper.source}</span>
                                </div>
                            </div>
                        </div>
                        ${tldrHtml}
                        <div class="paper-abstract-container">
                            <button class="abstract-toggle" onclick="toggleAbstract('${paper.paperId}')">
                                <span class="toggle-icon">‚ñ∂</span>
                                <span class="toggle-text">Abstract</span>
                            </button>
                            <div class="paper-abstract" id="abstract-${paper.paperId}" style="display: none;">
                                ${paper.abstract || '<em class="no-abstract">No abstract available</em>'}
                            </div>
                        </div>
                        <div class="card-footer">
                            <a href="${paper.url}" class="paper-link" target="_blank" rel="noopener noreferrer">
                                <span>${linkText}</span>
                                <span class="link-icon">‚Üó</span>
                            </a>
                            <div class="card-actions">
                                <button class="like-btn ${isLiked ? 'active' : ''}" onclick="likePaper('${paper.paperId}', event)" title="Like this paper">
                                    <span class="like-text">${isLiked ? 'Liked!' : 'Like'}</span>
                                </button>
                                <button class="dislike-btn ${isDisliked ? 'active' : ''}" onclick="dislikePaper('${paper.paperId}', event)" title="Dislike this paper">
                                    <span class="dislike-text">Pass</span>
                                </button>
                            </div>
                        </div>
                    </article>
                `;
            }
        </script>

        <!-- Paper Sidebar -->
        <div id="paperSidebar" class="paper-sidebar">
            <div class="sidebar-header">
                <h3 id="sidebarTitle" class="sidebar-title">Loading...</h3>
                <button class="sidebar-close" onclick="closeSidebar()">&times;</button>
            </div>
            <iframe id="paperFrame" class="sidebar-iframe"></iframe>
        </div>
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()"></div>


        {% if error %}
        <div class="error-banner">
            <div class="error-icon">!</div>
            <div class="error-content">
                <h3>Unable to Load Papers</h3>
                <p>{{ error }}</p>
                <button onclick="location.reload()" class="retry-btn">Retry</button>
            </div>
        </div>
        {% endif %}

        {% if info_message %}
        <div class="info-banner">
            <div class="info-content">
                <p>{{ info_message }}</p>
            </div>
        </div>
        {% endif %}

        {% if using_recommendations %}
        <div class="recommendations-banner">
            <div class="banner-icon">*</div>
            <div class="banner-content">
                <h3>Personalized Recommendations</h3>
                <p>These papers are recommended based on your liked papers</p>
            </div>
        </div>
        {% endif %}

        <div class="feed" id="feedContainer">
            {% for paper in papers %}
            <article class="paper-card" data-card-number="{{ loop.index }}" data-paper-id="{{ paper.paperId }}" data-paper-json='{{ paper | tojson | safe }}'>
                <div class="card-header">
                    <div class="paper-meta">
                        <h2 class="paper-title">{{ paper.title | safe }}</h2>
                        <div class="paper-info">
                            {% if paper.authors %}
                            <span class="authors">
                                {% if paper.authors|length <= 4 %}
                                    {# Show all authors if 4 or fewer #}
                                    {% for author in paper.authors %}
                                        {{ author.name }}{% if not loop.last %}, {% endif %}
                                    {% endfor %}
                                {% else %}
                                    {# Show first 2 and last 2 if more than 4 #}
                                    {{ paper.authors[0].name }}, {{ paper.authors[1].name }}, ... {{ paper.authors[-2].name }}, {{ paper.authors[-1].name }}
                                {% endif %}
                            </span>
                            {% endif %}
                            <span class="separator">‚Ä¢</span>
                            <span class="year">{{ paper.year }}</span>
                            {% if paper.venue %}
                            <span class="separator">‚Ä¢</span>
                            <span class="venue">{{ paper.venue }}</span>
                            {% endif %}
                            {% if paper.citationCount > 0 %}
                            <span class="separator">‚Ä¢</span>
                            <span class="citations">{{ paper.citationCount }} citations</span>
                            {% endif %}
                        </div>
                    </div>
                </div>

                {% if paper.tldr %}
                <div class="paper-tldr">
                    <strong>TL;DR:</strong> {{ paper.tldr | safe }}
                </div>
                {% endif %}

                <div class="paper-abstract-container">
                    <button class="abstract-toggle" onclick="toggleAbstract('{{ paper.paperId }}')">
                        <span class="toggle-icon">‚ñ∂</span>
                        <span class="toggle-text">Abstract</span>
                    </button>
                    <div class="paper-abstract" id="abstract-{{ paper.paperId }}" style="display: none;">
                        {% if paper.abstract %}
                            {{ paper.abstract | safe }}
                        {% else %}
                            <em class="no-abstract">No abstract available</em>
                        {% endif %}
                    </div>
                </div>

                <div class="card-footer">
                    {% if paper.url %}
                    {% if paper.source == 'bioRxiv' %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on bioRxiv</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% elif paper.source == 'OpenAlex' %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on publisher's page</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% else %}
                    <a href="{{ paper.url }}" class="paper-link" target="_blank" rel="noopener noreferrer">
                        <span>Read on Semantic Scholar</span>
                        <span class="link-icon">‚Üó</span>
                    </a>
                    {% endif %}
                    {% endif %}
                    <div class="card-actions">
                        <button class="like-btn" onclick="likePaper('{{ paper.paperId }}', event)" title="Like this paper">
                            <span class="like-text">Like</span>
                        </button>
                        <button class="dislike-btn" onclick="dislikePaper('{{ paper.paperId }}', event)" title="Dislike this paper">
                            <span class="dislike-text">Pass</span>
                        </button>
                    </div>
                </div>
            </article>
            {% endfor %}
        </div>

        {% if not papers %}
        <div class="empty-state">
            {% if not topics and not authors %}
            <div class="empty-icon">‚Üí</div>
            <h2>Start Your Research Journey</h2>
            <p>Enter your research interests above to generate a personalized feed of papers</p>
            {% else %}
            <div class="empty-icon">?</div>
            <h2>No papers found</h2>
            <p>Try adjusting your search topics</p>
            {% endif %}
        </div>
        {% endif %}
    </div>

    <!-- Load More Button - outside the collapsible feed -->
    {% if papers %}
    <div class="load-more-container" id="loadMoreContainer">
        <button onclick="loadMorePapers()" class="load-more-btn" id="loadMoreBtn">
            <span class="load-more-text">Load More Papers</span>
            <span class="load-more-icon">‚Üì</span>
        </button>
    </div>
    {% endif %}

    <!-- Clear Feedback Modal -->
    <div id="clearModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Clear Feedback</h3>
                <button class="modal-close" onclick="closeClearModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>What would you like to clear?</p>
                <div class="modal-actions">
                    <form method="POST" action="/feedback/clear/liked" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-liked-btn">
                            Clear Liked ({{ feedback.liked|length if feedback else 0 }})
                        </button>
                    </form>
                    <form method="POST" action="/feedback/clear/disliked" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-disliked-btn">
                            Clear Disliked ({{ feedback.disliked|length if feedback else 0 }})
                        </button>
                    </form>
                    <form method="POST" action="/feedback/clear" style="width: 100%;">
                        <button type="submit" class="modal-btn clear-all-btn">
                            Clear All Feedback
                        </button>
                    </form>
                </div>
                <button onclick="closeClearModal()" class="modal-btn cancel-btn">Cancel</button>
            </div>
        </div>
    </div>
</body>
</html>
